{"compilerOptions":{"css":"external","dev":true,"hmr":true},"configFile":false,"extensions":[".svelte"],"preprocess":[{"markup":"markup({ content, filename }) {\n      const s = new MagicString(content)\n      const ast = parse(content, { filename })\n\n      // Import path to import name\n      // e.g. ./foo.png => ___ASSET___0\n      /** @type {Map<string, string>} */\n      const imports = new Map()\n\n      /**\n       * @param {{ raw: string, start: number, end: number }} attributeValue\n       */\n      function addImport(attributeValue) {\n        const url = attributeValue.raw.trim()\n\n        // Skip if url points to id, e.g. sprite sheets\n        if (url.startsWith('#')) return\n\n        if (!http && /^https?:\\/\\//.test(url)) return\n\n        if (urlFilter && !urlFilter(url)) return\n\n        let importName = imports.get(url)\n\n        if (!importName) {\n          importName = importPrefix + imports.size\n          imports.set(url, importName)\n        }\n\n        // e.g. <img src=\"./foo.png\" /> => <img src=\"{___ASSET___0}\" />\n        s.update(attributeValue.start, attributeValue.end, `{${importName}}`)\n      }\n\n      let ignoreNextElement = false\n\n      // @ts-ignore\n      walk(ast.html, {\n        /**\n         * @param {import('svelte/types/compiler/interfaces').TemplateNode} node\n         */\n        enter(node) {\n          if (node.type === 'Comment') {\n            if (node.data.trim() === IGNORE_FLAG) {\n              ignoreNextElement = true\n            }\n          } else if (\n            node.type === 'Element' ||\n            // check component only when have custom sources, as the default object\n            // does not support component names (optimization)\n            (hasCustomSources && node.type === 'InlineComponent')\n          ) {\n            if (ignoreNextElement) {\n              ignoreNextElement = false\n              return\n            }\n\n            /** @type {Record<string, string>} */\n            let lazyAttributes\n\n            function getAttributes() {\n              if (!lazyAttributes) {\n                lazyAttributes = {}\n                node.attributes.forEach(\n                  /** @param {any} attr */ (attr) => {\n                    if (attr.type !== 'Attribute') return\n                    // Ensure text only, since text only attribute values will only have one element\n                    if (\n                      attr.value.length > 1 &&\n                      attr.value[0].type !== 'Text'\n                    ) {\n                      return\n                    }\n                    lazyAttributes[attr.name] = attr.value[0].raw\n                  },\n                )\n              }\n              return lazyAttributes\n            }\n\n            for (let i = 0; i < resolvedSources.length; i++) {\n              /** @type {import('.').AssetSource} */\n              const source = resolvedSources[i]\n\n              // Compare node tag match\n              if (source.tag === node.name) {\n                /**\n                 * @param {string} attr\n                 */\n                function getAttrValue(attr) {\n                  const attribute = node.attributes.find(\n                    /** @param {any} v */ (v) =>\n                      v.type === 'Attribute' && v.name === attr,\n                  )\n                  if (!attribute) return\n\n                  // Ensure value only consists of one element, and is of type \"Text\".\n                  // Which should only match instances of static `foo=\"bar\"` attributes.\n                  if (\n                    attribute.value.length !== 1 ||\n                    attribute.value[0].type !== 'Text'\n                  )\n                    return\n\n                  if (\n                    source.filter &&\n                    !source.filter({\n                      tag: source.tag,\n                      attribute: attr,\n                      value: attribute.value[0].data,\n                      attributes: getAttributes(),\n                    })\n                  )\n                    return\n\n                  return attribute.value[0]\n                }\n\n                // Check src\n                source.srcAttributes?.forEach((attr) => {\n                  const value = getAttrValue(attr)\n                  if (!value) return\n                  addImport(value)\n                })\n\n                // Check srcset\n                source.srcsetAttributes?.forEach((attr) => {\n                  const value = getAttrValue(attr)\n                  if (!value) return\n                  const srcsetRegex = /\\s*([^,\\s]+).*?(?:,|$)\\s*/gm\n                  let match\n                  while ((match = srcsetRegex.exec(value.raw))) {\n                    addImport({\n                      raw: match[1],\n                      start: value.start + match.index,\n                      end: value.start + match.index + match[1].length,\n                    })\n                  }\n                })\n              }\n            }\n          }\n        },\n      })\n\n      if (imports.size) {\n        let importText = ''\n        for (const [path, importName] of imports.entries()) {\n          importText += `import ${importName} from \"${path}\";`\n        }\n        if (ast.module) {\n          // @ts-ignore\n          s.appendLeft(ast.module.content.start, importText)\n        } else if (ast.instance) {\n          // @ts-ignore\n          s.appendLeft(ast.instance.content.start, importText)\n        } else {\n          s.append(`<script>${importText}</script>`)\n        }\n      }\n\n      return {\n        code: s.toString(),\n        map: s.generateMap(),\n      }\n    }"},{"markup":"async ({ content, filename }) => {\n        if (transformers.replace) {\n            const transformed = await (0, exports.transform)('replace', transformers.replace, {\n                content,\n                markup: content,\n                filename,\n            });\n            content = transformed.code;\n        }\n        return (0, markup_1.transformMarkup)({ content, filename }, markupTransformer, {\n            // we only pass the markupTagName because the rest of options\n            // is fetched internally by the `markupTransformer`\n            markupTagName,\n        });\n    }","script":"async ({ content, attributes, markup: fullMarkup, filename, }) => {\n        const transformResult = await scriptTransformer({\n            content,\n            attributes,\n            markup: fullMarkup,\n            filename,\n        });\n        let { code, map, dependencies, diagnostics } = transformResult;\n        if (transformers.babel) {\n            const transformed = await (0, exports.transform)('babel', getTransformerOptions('babel'), { content: code, markup: fullMarkup, map, filename, attributes });\n            code = transformed.code;\n            map = transformed.map;\n            dependencies = (0, utils_1.concat)(dependencies, transformed.dependencies);\n            diagnostics = (0, utils_1.concat)(diagnostics, transformed.diagnostics);\n        }\n        return { code, map, dependencies, diagnostics };\n    }","style":"async ({ content, attributes, markup: fullMarkup, filename, }) => {\n        const transformResult = await cssTransformer({\n            content,\n            attributes,\n            markup: fullMarkup,\n            filename,\n        });\n        let { code, map, dependencies } = transformResult;\n        const hasPostcss = await (0, utils_1.hasDepInstalled)('postcss');\n        // istanbul ignore else\n        if (hasPostcss) {\n            if (transformers.postcss) {\n                const { alias, lang } = (0, language_1.getLanguage)(attributes);\n                const postcssOptions = getTransformerOptions('postcss', (0, language_1.isAliasOf)(alias, lang) ? alias : null, \n                // todo: this seems wrong and ugly\n                { ignoreAliasOverride: true });\n                const transformed = await (0, exports.transform)('postcss', postcssOptions, {\n                    content: code,\n                    markup: fullMarkup,\n                    map,\n                    filename,\n                    attributes,\n                });\n                code = transformed.code;\n                map = transformed.map;\n                dependencies = (0, utils_1.concat)(dependencies, transformed.dependencies);\n            }\n            const transformed = await (0, exports.transform)('globalStyle', getTransformerOptions('globalStyle'), { content: code, markup: fullMarkup, map, filename, attributes });\n            code = transformed.code;\n            map = transformed.map;\n        }\n        else if ('global' in attributes) {\n            console.warn(`[svelte-preprocess] 'global' attribute found, but 'postcss' is not installed. 'postcss' is used to walk through the CSS and transform any necessary selector.`);\n        }\n        return { code, map, dependencies };\n    }"},{"script":"({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tif (basename.startsWith('+page.') || basename.startsWith('+layout.')) {\n\t\t\tconst match = content.match(options_regex);\n\t\t\tif (match) {\n\t\t\t\tconst fixed = basename.replace('.svelte', '(.server).js/ts');\n\n\t\t\t\tconst message =\n\t\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t\t`\\`${match[1]}\\` will be ignored — move it to ${fixed} instead. See https://svelte.dev/docs/kit/page-options for more information.`;\n\n\t\t\t\tif (!warned.has(message)) {\n\t\t\t\t\tconsole.log(message);\n\t\t\t\t\twarned.add(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","markup":"({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tconst has_children =\n\t\t\tcontent.includes('<slot') || (isSvelte5Plus() && content.includes('{@render'));\n\n\t\tif (basename.startsWith('+layout.') && !has_children) {\n\t\t\tconst message =\n\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t`\\`<slot />\\`${isSvelte5Plus() ? ' or `{@render ...}` tag' : ''}` +\n\t\t\t\t' missing — inner content will not be rendered';\n\n\t\t\tif (!warned.has(message)) {\n\t\t\t\tconsole.log(message);\n\t\t\t\twarned.add(message);\n\t\t\t}\n\t\t}\n\t}"}]}